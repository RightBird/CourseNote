# 计算机组成

## **Chapter1  Computer Abstractions and Technology**

### **CPU Time**

Cycle Per Instruction **(CPI)**：单个周期指令数（平均时可为小数）  
CPU Clock Cycles：时钟周期数  
Clock Cycle Time：每个时钟的时间  
Clock Rate：时钟周期  
Instruction Count **(IC)**：指令数

$$
\begin{align*}
CPU~Time&=CPU~Clock~Cycles\times Clock~Cycle~Time\\\\
&=\frac{CPU~CLock~Cycles}{Clock~Rate}\\\\
&=Instruction~Count\times CPI \times Clock~Cycle~Time\\\\
&=\frac{Instruction~Count\times CPI}{Clock Rate}&&&&&&&&&&&
\end{align*}
$$

$$
\begin{align*}
Average~CPI&=\frac{Clock~Cycles}{Instruction~Count}\\\\
&=\frac{\sum^n_{i=1}(CPI_i\times Instruction~Count_i)}{Instruction~Count}&&&&&&&&&&&&&&&
\end{align*}
$$

### **MIPS: Millions of Instructions Per Second**

$$
\begin{align*}
MIPS&=\frac{Instruction~Count}{Execution~Time\times 10^6}\\\\
&=\frac{Instruction~Count}{\frac{instruction~Count\times CPI}{Clock~Rate}\times 10^6}\\\\
&=\frac{Clock~Rate}{CPI\times 10^6}&&&&&&&&&&&&&&&&&&&&&
\end{align*}
$$



## **Chapter2  Instructions: Language of the Computer**

### **RISC-V assembly language** 

#### **Arithmetic**

<table style="table-layout: fixed; width: 100%;">
  <thead>
    <tr>
      <th style="width: 20%;"><strong>Instruction</strong></th>
      <th style="width: 20%;"><strong>Example</strong></th>
      <th style="width: 25%;"><strong>Meaning</strong></th>
      <th style="width: 35%;"><strong>Comments</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>add</td>
      <td>add x5,x6,x7</td>
      <td>x5 = x6 + x7</td>
      <td>Add two source register operands</td>
    </tr>
    <tr>
      <td>subtract</td>
      <td>sub x5,x6,x7</td>
      <td>x5 = x6 - x7</td>
      <td>First source register subtracts second one</td>
    </tr>
    <tr>
      <td>add immediate</td>
      <td>addi x5,x6,20</td>
      <td>x5 = x6 + 20</td>
      <td>Used to add constants</td>
    </tr>
  </tbody>
</table>



#### **Data transfer**
<table style="table-layout: fixed; width: 100%;">
  <thead>
    <tr>
      <th style="width: 20%;"><strong>Instruction</strong></th>
      <th style="width: 20%;"><strong>Example</strong></th>
      <th style="width: 25%;"><strong>Meaning</strong></th>
      <th style="width: 35%;"><strong>Comments</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>load doubleword</td>
      <td>ld x5, 40(x6)</td>
      <td>x5 = Memory[x6 + 40]</td>
      <td>doubleword from memory to register</td>
    </tr>
    <tr>
      <td>store doubleword</td>
      <td>sd x5, 40(x6)</td>
      <td>Memory[x6 + 40] = x5</td>
      <td>doubleword from register to memory</td>
    </tr>
    <tr>
      <td>load word</td>
      <td>lw x5, 40(x6)</td>
      <td>x5 = Memory[x6 + 40]</td>
      <td>word from memory to register</td>
    </tr>
    <tr>
      <td>load word, unsigned</td>
      <td>lwu x5, 40(x6)</td>
      <td>x5 = Memory[x6 + 40]</td>
      <td>Unsigned word from memory to register</td>
    </tr>
    <tr>
      <td>store word</td>
      <td>sw x5, 40(x6)</td>
      <td>Memory[x6 + 40] = x5</td>
      <td>word from register to memory</td>
    </tr>
    <tr>
      <td>load halfword</td>
      <td>lh x5, 40(x6)</td>
      <td>x5 = Memory[x6 + 40]</td>
      <td>Halfword from memory to register</td>
    </tr>
    <tr>
      <td>load halfword, unsigned</td>
      <td>lhu x5, 40(x6)</td>
      <td>x5 = Memory[x6 + 40]</td>
      <td>Unsigned halfword from memory to register</td>
    </tr>
    <tr>
      <td>store halfword</td>
      <td>sh x5, 40(x6)</td>
      <td>Memory[x6 + 40] = x5</td>
      <td>halfword from register to memory</td>
    </tr>
    <tr>
      <td>load byte</td>
      <td>lb x5, 40(x6)</td>
      <td>x5 = Memory[x6 + 40]</td>
      <td>byte from memory to register</td>
    </tr>
    <tr>
      <td>load byte, unsigned</td>
      <td>lbu x5, 40(x6)</td>
      <td>x5 = Memory[x6 + 40]</td>
      <td>Unsigned byte from memory to register</td>
    </tr>
    <tr>
      <td>store byte</td>
      <td>sb x5, 40(x6)</td>
      <td>Memory[x6 + 40] = x5</td>
      <td>byte from register to memory</td>
    </tr>
    <tr>
      <td>load reserved</td>
      <td>lr.d x5, (x6)</td>
      <td>x5 = Memory[x6]</td>
      <td>Load; 1st half of atomic swap</td>
    </tr>
    <tr>
      <td>store conditional</td>
      <td>sc.d x7, x5, (x6)</td>
      <td>Memory[x6] = x5; x7 = 0/1</td>
      <td>Store; 2nd half of atomic swap</td>
    </tr>
    <tr>
      <td>Load upper immediate</td>
      <td>lui x5, 0x12345</td>
      <td>x5 = 0x12345000</td>
      <td>Loads 20-bits constant shifted left 12 bits</td>
    </tr>
  </tbody>
</table>


#### **Logical**
<table style="table-layout: fixed; width: 100%;">
  <thead>
    <tr>
      <th style="width: 20%;"><strong>Instruction</strong></th>
      <th style="width: 20%;"><strong>Example</strong></th>
      <th style="width: 25%;"><strong>Meaning</strong></th>
      <th style="width: 35%;"><strong>Comments</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>and</td>
      <td>and x5, x6, 3</td>
      <td>x5 = x6 & 3</td>
      <td>Arithmetic shift right by register</td>
    </tr>
    <tr>
      <td>inclusive or</td>
      <td>or x5, x6, x7</td>
      <td>x5 = x6 | x7</td>
      <td>Bit-by-bit OR</td>
    </tr>
    <tr>
      <td>exclusive or</td>
      <td>xor x5, x6, x7</td>
      <td>x5 = x6 ^ x7</td>
      <td>Bit-by-bit XOR</td>
    </tr>
    <tr>
      <td>and immediate</td>
      <td>andi x5, x6, 20</td>
      <td>x5 = x6 & 20</td>
      <td>Bit-by-bit AND reg. with constant</td>
    </tr>
    <tr>
      <td>inclusive or immediate</td>
      <td>ori x5, x6, 20</td>
      <td>x5 = x6 | 20</td>
      <td>Bit-by-bit OR reg. with constant</td>
    </tr>
    <tr>
      <td>exclusive or immediate</td>
      <td>xori x5, x6, 20</td>
      <td>x5 = x6 ^ 20</td>
      <td>Bit-by-bit XOR reg. with constant</td>
    </tr>
  </tbody>
</table>


#### Shift

<table style="table-layout: fixed; width: 100%;">
  <thead>
    <tr>
      <th style="width: 20%;"><strong>Instruction</strong></th>
      <th style="width: 20%;"><strong>Example</strong></th>
      <th style="width: 25%;"><strong>Meaning</strong></th>
      <th style="width: 35%;"><strong>Comments</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>shift left logical</td>
      <td>sll x5, x6, x7</td>
      <td>x5 = x6 &lt;&lt; x7</td>
      <td>Shift left by register</td>
    </tr>
    <tr>
      <td>shift right logical</td>
      <td>srl x5, x6, x7</td>
      <td>x5 = x6 &gt;&gt; x7</td>
      <td>Shift right by register</td>
    </tr>
    <tr>
      <td>shift right arithmetic</td>
      <td>sra x5, x6, x7</td>
      <td>x5 = x6 &gt;&gt; x7</td>
      <td>Arithmetic shift right by register</td>
    </tr>
    <tr>
      <td>shift left logical immediate</td>
      <td>slli x5, x6, 3</td>
      <td>x5 = x6 &lt;&lt; 3</td>
      <td>Shift left by immediate</td>
    </tr>
    <tr>
      <td>shift right logical immediate</td>
      <td>srli x5, x6, 3</td>
      <td>x5 = x6 &gt;&gt; 3</td>
      <td>Shift right by immediate</td>
    </tr>
    <tr>
      <td>shift right arithmetic immediate</td>
      <td>srai x5, x6, 3</td>
      <td>x5 = x6 &gt;&gt; 3</td>
      <td>Arithmetic shift right by immediate</td>
    </tr>
  </tbody>
</table>

!!!NOTE
    **sra（算数右移）：**右移，最高位补符号位
    **srl（逻辑右移）：**右移，最高位补0



#### **Conditional branch**

<table style="table-layout: fixed; width: 100%;">
  <thead>
    <tr>
      <th style="width: 20%;"><strong>Instruction</strong></th>
      <th style="width: 20%;"><strong>Example</strong></th>
      <th style="width: 25%;"><strong>Meaning</strong></th>
      <th style="width: 35%;"><strong>Comments</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>branch if equal</td>
      <td>beq x5, x6, 100</td>
      <td>if(x5 == x6) go to PC+100</td>
      <td>PC-relative branch if registers equal</td>
    </tr>
    <tr>
      <td>branch if not equal</td>
      <td>bne x5, x6, 100</td>
      <td>if(x5 != x6) go to PC+100</td>
      <td>PC-relative branch if registers not equal</td>
    </tr>
    <tr>
      <td>branch if less than</td>
      <td>blt x5, x6, 100</td>
      <td>if(x5 &lt; x6) go to PC+100</td>
      <td>PC-relative branch if registers less</td>
    </tr>
    <tr>
      <td>branch if greater or equal</td>
      <td>bge x5, x6, 100</td>
      <td>if(x5 &gt;= x6) go to PC+100</td>
      <td>PC-relative branch if registers greater or equal</td>
    </tr>
    <tr>
      <td>branch if less, unsigned</td>
      <td>bltu x5, x6, 100</td>
      <td>if(x5 &lt; x6) go to PC+100</td>
      <td>PC-relative branch if registers less, unsigned</td>
    </tr>
    <tr>
      <td>branch if greater or equal, unsigned</td>
      <td>bgeu x5, x6, 100</td>
      <td>if(x5 &gt;= x6) go to PC+100</td>
      <td>PC-relative branch if registers greater or equal, unsigned</td>
    </tr>
  </tbody>
</table>



#### **Unconditional branch**
<table style="table-layout: fixed; width: 100%;">
  <thead>
    <tr>
      <th style="width: 20%;"><strong>Instruction</strong></th>
      <th style="width: 20%;"><strong>Example</strong></th>
      <th style="width: 25%;"><strong>Meaning</strong></th>
      <th style="width: 35%;"><strong>Comments</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>jump and link</td>
      <td>jal x1, 100</td>
      <td>x1=PC+4 ; go to PC + 100</td>
      <td>PC-relative procedure call</td>
    </tr>
    <tr>
      <td>jump and link register</td>
      <td>jalr x1, 100(x5)</td>
      <td>x1=PC+4 ; go to x5 + 100</td>
      <td>procedure return; indirect call</td>
    </tr>
  </tbody>
</table>





### **$\blacktriangledown$  Register Operands**

**32 registers in RISC-V**（越少越快，寄存器个数一般不超过32个）

**64 bits (doubleword) for each register in RISC-V**




### **$\blacktriangledown$ RISC-V register conventions（约定）**

| Name    | Register  name | Usage                          | Preserved  On  call? |
| ------- | -------------- | ------------------------------ | -------------------- |
| x0      | 0              | The  constant value 0          | n.a.                 |
| x1(ra)  | 1              | Return  address(link register) | yes                  |
| x2(sp)  | 2              | Stack  pointer                 | yes                  |
| x3(gp)  | 3              | Global  pointer                | yes                  |
| x4(tp)  | 4              | Thread  pointer                | yes                  |
| x5-x7   | 5-7            | Temporaries                    | no                   |
| x8-x9   | 8-9            | Saved                          | yes                  |
| x10-x17 | 10-17          | Arguments/results              | no                   |
| x18-x27 | 18-27          | Saved                          | yes                  |
| x28-x31 | 28-31          | Temporaries                    | no                   |



### **$\blacktriangledown$ RISC-V 指令格式**

#### **R-format**

![1](pic/1.png)

#### **I-format**

<img src="./pic/2.png" alt="2" style="zoom:150%;" />

#### **S-format**

![3](pic/3.jpg)





## **Chapter3  Arithmetic for Computer** 

### **数字格式**

| Sign Magnitude | One's Complement（反码） | Two's Complement（补码） |
| :------------: | :----------------------: | :----------------------: |
|    000 = +0    |         000 = +0         |         000 = +0         |
|    001 = +1    |         001 = +1         |         001 = +1         |
|    010 = +2    |         010 = +2         |         010 = +2         |
|    011 = +3    |         011 = +3         |         011 = +3         |
|    100 = -0    |         100 = -3         |         100 = -4         |
|    101 = -1    |         101 = -2         |         101 = -3         |
|    110 = -2    |         110 = -1         |         110 = -2         |
|    111 = -3    |         111 = -0         |         111 = -1         |

**Two's Biased notation（偏码）:**

$$
\begin{align*}
&通常：[X]_b＝~2^n~＋~Ｘ\\
\\
&IEEE~754: [X]_b＝~2^n-1~＋~Ｘ&&&&&&&&&&&&&&&&&&&&&&&&&\\
\end{align*}
$$

### **Integer**

#### **Adder**

#### **Carry Lookahead Adder (CLA)**

$$
\begin{align*}
C_1&=G_0+P_0C_0\\\\
C_2&=G_1+P_1C_1=G_1+P_1(G_0+P_0C_0)\\\\
&=G_1+P_1G_0+P_1P_0C_0\\\\
C_3&=G_2+P_2C_2=G_2+P_2(G_1+P_1G_0+P_1P_0C_0)\\\\
&=G_2+P_2G_1+P_2P_1G_0+P_2P_1P_0C_0\\\\
G_4&=G_3+P_3G_3=G_3+P_3(P_2G_1+P_2P_1G_0+P_2P_1P_0C_0)\\\\
&=G_3+P_3P_2G_1+P_3P_2P_1G_0+P_3P_2P_1P_0C_0&&&&&&&&&&&\\\\
\end{align*}
$$

<img src="./pic/4.png" alt="4" style="zoom: 50%;" /> 

#### **Multiplier**

**• Booth's Algorithm**

 **操作:最后一位补0**
 
$$
\begin{align*}
1~0:~&左半部分减乘数，右移结果\\
1~1:~&右移结果\\
0~1:~&左半部分加乘数，右移结果\\
0~0:~&右移结果&&&&&&&&&&&&&&&&&&&&&&&&\\
\end{align*}
$$

**Example**

$2\times (-3)=-6$

$0010\times 1101=1111~1010$

<img src="./pic/5.png" alt="5" style="zoom:22%;" /> 

#### **Division** 

**Example: 7 / 2**

<img src="./pic/6.png" alt="6" style="zoom: 50%;" /> 

符号数相除：转出同符号相除，最后添加符号

除以0：overflow

### **Floating Point**

#### **IEEE标准**

<img src="./pic/9.png" alt="image-20240924144105636" style="zoom: 33%;" /> 

$$
X=(-1)^S+(1+Fraction)\times2^{(Exponent-Bias)}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$$

S：符号位（0正1负）

Exponent:指数部分

• single:8bits        Bias=127

• double:11bits       Bias=1023

Fraction: 小数部分

• single: 23 bits

• double: 52 bits

#### **范围**

$$
\begin{align*}
Sing&le:\\
&Samlles:\pm1.0\times2^{-126}\approx\pm1.2\times10^{-38}\\
&Largest:\pm2.0\times2^{+127}\approx\pm3.4\times10^{38}\\
Doub&le:\\
&Samlles:\pm1.0\times2^{-1022}\approx\pm2.2\times10^{-308}\\
&Largest:\pm2.0\times2^{+1023}\approx\pm1.8\times10^{308}&&&&&&&&&&&&&&&&&\\
\end{align*}
$$

#### **Denormal Numbers**

$$
\begin{align*}
&Exponent=000……0\\\\
\Rightarrow&X=(-1)^S+(0+Fraction)\times2^{(Exponent-Bias)}&&&&&&&&&&&&&&&\\
\end{align*}
$$

#### **Infinity**

$$
Exponent = 111...1,~~~Fraction = 000...0~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$$

#### **NANs**

$$
Exponent = 111...1,~~Fraction ≠ 000...0~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$$

#### **Addition**

**Example:   $9.999\times10^1 + 1.610 \times 10^{-1}$**
<img src="./pic/7.png" alt="7" style="zoom:33%;" /> 

!!!NOTE
    **大数吃小数**
    
    $$
    \begin{aligned}
    &计算\frac{1}{1}+\frac{1}{2}+\frac{1}{3}+……+\frac{1}{n},\\\\
    &for(i=n;i>=1;i--)~~精度大于~~for(i=1;u<=n;i++)&&&&&&&&&&&&&&&&
    \end{aligned}
    $$

#### **Multiplication**

$$
(s_1 \times 2^{e_1}) \times (s_2 \times 2^{e_2})  = (s_1 \times s_2) \times 2^{e_1+ e_2}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$$



**Example:   $0.5_{ten}\times-0.4375_{ten}~\Rightarrow~1.000_{two}\times2^{-1}\times-1.110_{two}\times2^{-2}$**

<img src="./pic/8.png" alt="8" style="zoom: 40%;" /> 

#### **sticky bit**

-----
